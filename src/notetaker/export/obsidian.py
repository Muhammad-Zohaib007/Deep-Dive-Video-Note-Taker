"""Obsidian-compatible Markdown export with YAML frontmatter.

Produces Markdown files that integrate seamlessly with Obsidian vaults:
- YAML frontmatter with title, date, tags, source, and custom properties
- Wikilink-compatible formatting
- Tag-based organization (#video-notes, topic tags)
- Callout blocks for action items
"""

from __future__ import annotations

import re
from datetime import datetime
from pathlib import Path
from typing import Optional

from notetaker.models import GeneratedOutput, VideoMetadata
from notetaker.utils.logging import get_logger

logger = get_logger("export.obsidian")


def _extract_tags(output: GeneratedOutput) -> list[str]:
    """Extract tags from note content for Obsidian organization."""
    tags = ["video-notes"]

    # Extract topic keywords from section headings
    for section in output.structured_notes.sections:
        # Convert heading to tag-safe format: lowercase, hyphenated, no specials
        tag = re.sub(r"[^a-z0-9\s-]", "", section.heading.lower())
        tag = re.sub(r"\s+", "-", tag.strip())
        if tag and len(tag) > 2:
            tags.append(tag)

    return list(dict.fromkeys(tags))  # dedupe preserving order


def generate_obsidian_markdown(
    output: GeneratedOutput,
    metadata: Optional[VideoMetadata] = None,
    extra_tags: Optional[list[str]] = None,
    vault_link_style: str = "wikilink",
) -> str:
    """Generate Obsidian-compatible Markdown with YAML frontmatter.

    Args:
        output: The generated notes, timestamps, and action items.
        metadata: Optional video metadata for frontmatter.
        extra_tags: Additional tags to include in frontmatter.
        vault_link_style: Link style - 'wikilink' for [[links]] or 'markdown' for [text](url).

    Returns:
        Formatted Markdown string with YAML frontmatter.
    """
    lines: list[str] = []
    notes = output.structured_notes

    # --- YAML Frontmatter ---
    lines.append("---")
    lines.append(f"title: \"{notes.title}\"")

    if metadata:
        lines.append(f"date: {metadata.processing_date[:10]}")
        if metadata.source_url:
            lines.append(f"source: \"{metadata.source_url}\"")
        lines.append(f"duration: {metadata.duration_seconds:.0f}")
        lines.append(f"video_id: \"{metadata.video_id}\"")
        lines.append(f"whisper_model: \"{metadata.whisper_model}\"")
        lines.append(f"llm_model: \"{metadata.ollama_model}\"")
        lines.append(f"processing_time: {metadata.processing_time_seconds:.1f}")
    else:
        lines.append(f"date: {datetime.now().strftime('%Y-%m-%d')}")

    # Tags
    tags = _extract_tags(output)
    if extra_tags:
        tags.extend(extra_tags)
        tags = list(dict.fromkeys(tags))  # dedupe
    lines.append("tags:")
    for tag in tags:
        lines.append(f"  - {tag}")

    lines.append(f"type: video-note")
    lines.append("---")
    lines.append("")

    # --- Title ---
    lines.append(f"# {notes.title}")
    lines.append("")

    # --- Metadata callout ---
    if metadata:
        lines.append("> [!info] Video Info")
        if metadata.source_url:
            lines.append(f"> **Source:** {metadata.source_url}")
        duration_min = metadata.duration_seconds / 60
        lines.append(f"> **Duration:** {duration_min:.1f} minutes")
        lines.append(f"> **Processed:** {metadata.processing_date[:10]}")
        lines.append(f"> **Models:** Whisper {metadata.whisper_model} | {metadata.ollama_model}")
        lines.append("")

    # --- Summary ---
    if notes.summary:
        lines.append("## Summary")
        lines.append("")
        lines.append(notes.summary)
        lines.append("")

    # --- Sections ---
    if notes.sections:
        lines.append("## Notes")
        lines.append("")
        for section in notes.sections:
            lines.append(f"### {section.heading}")
            lines.append("")
            for point in section.key_points:
                lines.append(f"- {point}")
            lines.append("")

    # --- Timestamps ---
    if output.timestamps:
        lines.append("## Key Timestamps")
        lines.append("")
        for ts in output.timestamps:
            lines.append(f"- **{ts.time}** - {ts.label}")
        lines.append("")

    # --- Action Items (Obsidian task format) ---
    if output.action_items:
        lines.append("## Action Items")
        lines.append("")
        lines.append("> [!todo] Tasks")
        for item in output.action_items:
            assignee = f" `@{item.assignee}`" if item.assignee else ""
            ts = f" `[{item.timestamp}]`" if item.timestamp else ""
            lines.append(f"> - [ ] {item.action}{assignee}{ts}")
        lines.append("")

    # --- Footer ---
    lines.append("---")
    lines.append(f"*Generated by Deep-Dive Video Note Taker on {datetime.now().strftime('%Y-%m-%d %H:%M')}*")
    lines.append("")

    return "\n".join(lines)


def export_obsidian(
    output: GeneratedOutput,
    metadata: Optional[VideoMetadata],
    path: Path,
    extra_tags: Optional[list[str]] = None,
) -> None:
    """Export notes as an Obsidian-compatible Markdown file.

    Args:
        output: Generated notes.
        metadata: Video metadata.
        path: Output file path.
        extra_tags: Additional tags for frontmatter.
    """
    path = Path(path)
    path.parent.mkdir(parents=True, exist_ok=True)

    content = generate_obsidian_markdown(output, metadata, extra_tags)

    with open(path, "w", encoding="utf-8") as f:
        f.write(content)

    logger.info(f"Obsidian Markdown exported: {path}")
